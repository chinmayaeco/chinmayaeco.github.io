<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GARCH Family Models Simulation Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .model-info {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .visualization {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 500px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        button {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .model-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .model-btn {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            background-color: #e9ecef;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .model-btn.active {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
            color: white;
        }
        
        .model-btn:hover {
            background-color: #d8dbe0;
        }
        
        .model-btn.active:hover {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f);
        }
        
        .math-formula {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .references {
            margin-top: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .references h2 {
            margin-bottom: 15px;
            color: #1a2a6c;
        }
        
        .references ul {
            list-style-type: none;
        }
        
        .references li {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }
        
        .references li:before {
            content: "•";
            color: #b21f1f;
            font-weight: bold;
            position: absolute;
            left: 0;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
            
            .model-selector {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>GARCH Family Models Simulation Tool</h1>
            <p class="subtitle">For Academic Research in Financial Econometrics</p>
        </header>
        
        <div class="model-selector">
            <button class="model-btn active" data-model="garch">GARCH</button>
            <button class="model-btn" data-model="egarch">EGARCH</button>
            <button class="model-btn" data-model="gjr-garch">GJR-GARCH</button>
            <button class="model-btn" data-model="dcc-garch">DCC-GARCH</button>
            <button class="model-btn" data-model="figarch">FIGARCH</button>
        </div>
        
        <div class="content">
            <div class="controls">
                <div class="form-group">
                    <label for="model">Model Type</label>
                    <select id="model">
                        <option value="garch">GARCH (1,1)</option>
                        <option value="egarch">EGARCH (1,1)</option>
                        <option value="gjr-garch">GJR-GARCH (1,1)</option>
                        <option value="dcc-garch">DCC-GARCH</option>
                        <option value="figarch">FIGARCH</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="observations">Number of Observations</label>
                    <input type="number" id="observations" value="1000" min="100" max="10000">
                </div>
                
                <div class="form-group">
                    <label for="omega">Omega (ω)</label>
                    <input type="number" id="omega" value="0.1" step="0.01" min="0.01" max="1">
                </div>
                
                <div class="form-group">
                    <label for="alpha">Alpha (α)</label>
                    <input type="number" id="alpha" value="0.1" step="0.01" min="0.01" max="0.5">
                </div>
                
                <div class="form-group">
                    <label for="beta">Beta (β)</label>
                    <input type="number" id="beta" value="0.85" step="0.01" min="0.1" max="0.95">
                </div>
                
                <div id="additional-params">
                    <!-- Additional parameters will be added here based on model selection -->
                </div>
                
                <button id="simulate-btn">Run Simulation</button>
            </div>
            
            <div class="visualization">
                <canvas id="simulation-chart"></canvas>
            </div>
        </div>
        
        <div class="model-info">
            <h2 id="model-title">GARCH Model</h2>
            <div class="math-formula">
                <p id="model-formula">$$ \sigma_t^2 = \omega + \alpha \varepsilon_{t-1}^2 + \beta \sigma_{t-1}^2 $$</p>
            </div>
            <p id="model-description">
                The Generalized Autoregressive Conditional Heteroskedasticity (GARCH) model, introduced by Bollerslev (1986), 
                extends the ARCH model by including lagged conditional variances. This allows for a more parsimonious representation 
                of persistent volatility clustering commonly observed in financial time series.
            </p>
        </div>
        
        <div class="references">
            <h2>Key References</h2>
            <ul>
                <li>Bollerslev, T. (1986). Generalized autoregressive conditional heteroskedasticity. Journal of Econometrics, 31(3), 307-327.</li>
                <li>Engle, R. F. (1982). Autoregressive conditional heteroscedasticity with estimates of the variance of United Kingdom inflation. Econometrica, 50(4), 987-1007.</li>
                <li>Nelson, D. B. (1991). Conditional heteroskedasticity in asset returns: A new approach. Econometrica, 59(2), 347-370.</li>
                <li>Glosten, L. R., Jagannathan, R., & Runkle, D. E. (1993). On the relation between the expected value and the volatility of the nominal excess return on stocks. The Journal of Finance, 48(5), 1779-1801.</li>
                <li>Engle, R. F. (2002). Dynamic conditional correlation: A simple class of multivariate generalized autoregressive conditional heteroskedasticity models. Journal of Business & Economic Statistics, 20(3), 339-350.</li>
                <li>Baillie, R. T., Bollerslev, T., & Mikkelsen, H. O. (1996). Fractionally integrated generalized autoregressive conditional heteroskedasticity. Journal of Econometrics, 74(1), 3-30.</li>
            </ul>
        </div>
    </div>

    <script>
        // Model information
        const models = {
            garch: {
                title: "GARCH Model",
                formula: "$$ \\sigma_t^2 = \\omega + \\alpha \\varepsilon_{t-1}^2 + \\beta \\sigma_{t-1}^2 $$",
                description: "The Generalized Autoregressive Conditional Heteroskedasticity (GARCH) model, introduced by Bollerslev (1986), extends the ARCH model by including lagged conditional variances. This allows for a more parsimonious representation of persistent volatility clustering commonly observed in financial time series."
            },
            egarch: {
                title: "EGARCH Model",
                formula: "$$ \\ln(\\sigma_t^2) = \\omega + \\alpha \\left|\\frac{\\varepsilon_{t-1}}{\\sigma_{t-1}}\\right| + \\gamma \\frac{\\varepsilon_{t-1}}{\\sigma_{t-1}} + \\beta \\ln(\\sigma_{t-1}^2) $$",
                description: "The Exponential GARCH (EGARCH) model, proposed by Nelson (1991), models the logarithm of conditional variance. This formulation ensures that variance remains positive without parameter restrictions and allows for asymmetric effects of positive and negative shocks on volatility."
            },
            "gjr-garch": {
                title: "GJR-GARCH Model",
                formula: "$$ \\sigma_t^2 = \\omega + (\\alpha + \\gamma I_{t-1}) \\varepsilon_{t-1}^2 + \\beta \\sigma_{t-1}^2 $$",
                description: "The GJR-GARCH model, developed by Glosten, Jagannathan, and Runkle (1993), extends GARCH to account for leverage effects. It includes an indicator function that differentiates between positive and negative shocks, allowing for asymmetric volatility responses."
            },
            "dcc-garch": {
                title: "DCC-GARCH Model",
                formula: "$$ Q_t = (1 - \\theta_1 - \\theta_2) \\bar{Q} + \\theta_1 \\varepsilon_{t-1} \\varepsilon_{t-1}' + \\theta_2 Q_{t-1} $$",
                description: "The Dynamic Conditional Correlation GARCH (DCC-GARCH) model, introduced by Engle (2002), is a multivariate GARCH specification that allows time-varying correlations between multiple assets while keeping the model computationally tractable."
            },
            figarch: {
                title: "FIGARCH Model",
                formula: "$$ \\sigma_t^2 = \\omega + [1 - \\beta(L) - \\phi(L)(1-L)^d] \\varepsilon_t^2 + \\beta(L) \\sigma_t^2 $$",
                description: "The Fractionally Integrated GARCH (FIGARCH) model, proposed by Baillie, Bollerslev, and Mikkelsen (1996), incorporates long memory in volatility by using fractional integration. This allows for slow hyperbolic decay in the autocorrelation of squared returns."
            }
        };

        // DOM elements
        const modelButtons = document.querySelectorAll('.model-btn');
        const modelSelect = document.getElementById('model');
        const modelTitle = document.getElementById('model-title');
        const modelFormula = document.getElementById('model-formula');
        const modelDescription = document.getElementById('model-description');
        const additionalParams = document.getElementById('additional-params');
        const simulateBtn = document.getElementById('simulate-btn');
        
        // Chart initialization
        const ctx = document.getElementById('simulation-chart').getContext('2d');
        let simulationChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Returns',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 1,
                        tension: 0.1
                    },
                    {
                        label: 'Volatility',
                        data: [],
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 1,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'GARCH Simulation Results'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });

        // Update model information based on selection
        function updateModelInfo(model) {
            modelTitle.textContent = models[model].title;
            modelFormula.innerHTML = models[model].formula;
            modelDescription.textContent = models[model].description;
            
            // Update additional parameters based on model
            additionalParams.innerHTML = '';
            
            if (model === 'egarch') {
                additionalParams.innerHTML = `
                    <div class="form-group">
                        <label for="gamma">Gamma (γ)</label>
                        <input type="number" id="gamma" value="0.1" step="0.01" min="-0.5" max="0.5">
                    </div>
                `;
            } else if (model === 'gjr-garch') {
                additionalParams.innerHTML = `
                    <div class="form-group">
                        <label for="gamma">Gamma (γ)</label>
                        <input type="number" id="gamma" value="0.05" step="0.01" min="0" max="0.5">
                    </div>
                `;
            } else if (model === 'dcc-garch') {
                additionalParams.innerHTML = `
                    <div class="form-group">
                        <label for="theta1">Theta 1 (θ₁)</label>
                        <input type="number" id="theta1" value="0.05" step="0.01" min="0" max="0.5">
                    </div>
                    <div class="form-group">
                        <label for="theta2">Theta 2 (θ₂)</label>
                        <input type="number" id="theta2" value="0.9" step="0.01" min="0" max="0.95">
                    </div>
                `;
            } else if (model === 'figarch') {
                additionalParams.innerHTML = `
                    <div class="form-group">
                        <label for="d">Fractional Parameter (d)</label>
                        <input type="number" id="d" value="0.5" step="0.01" min="0" max="1">
                    </div>
                `;
            }
            
            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typeset();
            }
        }

        // GARCH simulation function
        function simulateGARCH(omega, alpha, beta, n) {
            const returns = new Array(n);
            const volatility = new Array(n);
            
            // Initialize
            returns[0] = 0;
            volatility[0] = Math.sqrt(omega / (1 - alpha - beta));
            
            // Generate the series
            for (let i = 1; i < n; i++) {
                volatility[i] = Math.sqrt(omega + alpha * Math.pow(returns[i-1], 2) + beta * Math.pow(volatility[i-1], 2));
                returns[i] = volatility[i] * (Math.random() - 0.5) * 3.46; // Approximate standard normal
            }
            
            return { returns, volatility };
        }

        // EGARCH simulation function
        function simulateEGARCH(omega, alpha, beta, gamma, n) {
            const returns = new Array(n);
            const volatility = new Array(n);
            
            // Initialize
            returns[0] = 0;
            volatility[0] = Math.exp(omega / 2);
            
            // Generate the series
            for (let i = 1; i < n; i++) {
                const z = returns[i-1] / volatility[i-1];
                const logVol = omega + alpha * (Math.abs(z) - Math.sqrt(2/Math.PI)) + gamma * z + beta * Math.log(volatility[i-1]);
                volatility[i] = Math.exp(logVol / 2);
                returns[i] = volatility[i] * (Math.random() - 0.5) * 3.46; // Approximate standard normal
            }
            
            return { returns, volatility };
        }

        // GJR-GARCH simulation function
        function simulateGJRGARCH(omega, alpha, beta, gamma, n) {
            const returns = new Array(n);
            const volatility = new Array(n);
            
            // Initialize
            returns[0] = 0;
            volatility[0] = Math.sqrt(omega / (1 - alpha - beta - gamma/2));
            
            // Generate the series
            for (let i = 1; i < n; i++) {
                const indicator = returns[i-1] < 0 ? 1 : 0;
                volatility[i] = Math.sqrt(omega + (alpha + gamma * indicator) * Math.pow(returns[i-1], 2) + beta * Math.pow(volatility[i-1], 2));
                returns[i] = volatility[i] * (Math.random() - 0.5) * 3.46; // Approximate standard normal
            }
            
            return { returns, volatility };
        }

        // DCC-GARCH simulation function (simplified)
        function simulateDCCGARCH(omega, alpha, beta, theta1, theta2, n) {
            // For simplicity, we'll simulate two correlated assets
            const returns1 = new Array(n);
            const returns2 = new Array(n);
            const volatility1 = new Array(n);
            const volatility2 = new Array(n);
            const correlation = new Array(n);
            
            // Initialize
            returns1[0] = 0;
            returns2[0] = 0;
            volatility1[0] = Math.sqrt(omega / (1 - alpha - beta));
            volatility2[0] = Math.sqrt(omega / (1 - alpha - beta));
            correlation[0] = 0.5;
            
            // Generate the series
            for (let i = 1; i < n; i++) {
                // Update volatilities (using GARCH for each asset)
                volatility1[i] = Math.sqrt(omega + alpha * Math.pow(returns1[i-1], 2) + beta * Math.pow(volatility1[i-1], 2));
                volatility2[i] = Math.sqrt(omega + alpha * Math.pow(returns2[i-1], 2) + beta * Math.pow(volatility2[i-1], 2));
                
                // Update correlation (simplified DCC process)
                correlation[i] = (1 - theta1 - theta2) * 0.5 + theta1 * 
                                (returns1[i-1]/volatility1[i-1]) * (returns2[i-1]/volatility2[i-1]) + 
                                theta2 * correlation[i-1];
                
                // Generate correlated returns
                const z1 = (Math.random() - 0.5) * 3.46;
                const z2 = correlation[i] * z1 + Math.sqrt(1 - Math.pow(correlation[i], 2)) * (Math.random() - 0.5) * 3.46;
                
                returns1[i] = volatility1[i] * z1;
                returns2[i] = volatility2[i] * z2;
            }
            
            // For visualization, we'll just return the first asset
            return { returns: returns1, volatility: volatility1 };
        }

        // FIGARCH simulation function (simplified)
        function simulateFIGARCH(omega, alpha, beta, d, n) {
            const returns = new Array(n);
            const volatility = new Array(n);
            
            // Initialize
            returns[0] = 0;
            volatility[0] = Math.sqrt(omega / (1 - alpha - beta));
            
            // Generate the series (simplified implementation)
            for (let i = 1; i < n; i++) {
                // Simplified FIGARCH - in practice, this would require fractional differencing
                volatility[i] = Math.sqrt(omega + alpha * Math.pow(returns[i-1], 2) + beta * Math.pow(volatility[i-1], 2));
                returns[i] = volatility[i] * (Math.random() - 0.5) * 3.46;
            }
            
            return { returns, volatility };
        }

        // Run simulation based on selected model
        function runSimulation() {
            const model = modelSelect.value;
            const n = parseInt(document.getElementById('observations').value);
            const omega = parseFloat(document.getElementById('omega').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const beta = parseFloat(document.getElementById('beta').value);
            
            let result;
            
            switch(model) {
                case 'garch':
                    result = simulateGARCH(omega, alpha, beta, n);
                    break;
                case 'egarch':
                    const gammaEG = parseFloat(document.getElementById('gamma').value);
                    result = simulateEGARCH(omega, alpha, beta, gammaEG, n);
                    break;
                case 'gjr-garch':
                    const gammaGJR = parseFloat(document.getElementById('gamma').value);
                    result = simulateGJRGARCH(omega, alpha, beta, gammaGJR, n);
                    break;
                case 'dcc-garch':
                    const theta1 = parseFloat(document.getElementById('theta1').value);
                    const theta2 = parseFloat(document.getElementById('theta2').value);
                    result = simulateDCCGARCH(omega, alpha, beta, theta1, theta2, n);
                    break;
                case 'figarch':
                    const d = parseFloat(document.getElementById('d').value);
                    result = simulateFIGARCH(omega, alpha, beta, d, n);
                    break;
                default:
                    result = simulateGARCH(omega, alpha, beta, n);
            }
            
            // Update chart
            const labels = Array.from({length: n}, (_, i) => i);
            simulationChart.data.labels = labels;
            simulationChart.data.datasets[0].data = result.returns;
            simulationChart.data.datasets[1].data = result.volatility;
            simulationChart.update();
        }

        // Event listeners
        modelButtons.forEach(button => {
            button.addEventListener('click', () => {
                modelButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                modelSelect.value = button.dataset.model;
                updateModelInfo(button.dataset.model);
            });
        });

        modelSelect.addEventListener('change', () => {
            modelButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.model === modelSelect.value);
            });
            updateModelInfo(modelSelect.value);
        });

        simulateBtn.addEventListener('click', runSimulation);

        // Initialize with GARCH model
        updateModelInfo('garch');
        
        // Run initial simulation
        setTimeout(runSimulation, 500);
    </script>
</body>
</html>
